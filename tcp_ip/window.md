### 滑动窗口
```
TCP的发送过程由滑动窗口控制，而滑动窗口的大小受限于发送窗口和拥塞窗口，拥塞窗口由拥塞控制算法的代表，而发送窗口是流量控制算法的代表，
TCP并不是每一个报文段都会回复ACK的，可能会对两个报文段发送一个ACK，也可能会对多个报文段发送1个ACK【累计ACK】，比如说发送方有1/2/3 3个报文段，先发送了2,3 两个报文段，但是接收方期望收到1报文段，这个时候2,3报文段就只能放在缓存中等待报文1的空洞被填上，如果报文1，一直不来，报文2/3也将被丢弃，如果报文1来了，那么会发送一个ACK对这3个报文进行一次确认。
```

### 发送窗口
```
对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。
“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。
其中“未接收准备接收”称之为接收窗口。
```
![TCP Option](https://github.com/ruansheng/technology-study/blob/master/images/send_wnd.jpg)
```
struct tcp_sock {
...
	//下一个要发送的序号，即序号等于snd_nxt的数据还没有发送
	u32	snd_nxt;	/* Next sequence we send		*/
	//已经发送，但是还没有被确认的最小序号，注意序号等于snd_una的数据已经发送，
	//最想收到的确认号要大于snd_una。但是有一个特殊情况，如果发送的所有数据都
	//已经被确认，那么snd_una将等于下一个要发送的数据，即snd_una代表的数据还
	//没有发送，见下面tcp_ack()更新snd_una就可以理解这一点了
	u32	snd_una;	/* First byte we want an ack for	*/
	//发送窗口大小，以字节为单位，来源于输入段首部的窗口字段，即对端接收缓冲区的剩余大小
	u32	snd_wnd;	/* The window we expect to receive	*/
	//记录到目前为止对端通告过的窗口的最大值，可以代表对端接收缓冲区的最大值
	u32	max_window;	/* Maximal window ever seen from peer	*/
	//写系统调用一旦成功返回，说明数据一被TCP协议接收，这时就要为每一个数据分配一个序号，
	//write_seq就是下一个要分配的序号，其初始值由secure_tcp_sequence_number()基于
	//算法生成。注意等于write_seq的序号还没有被分配
	u32	write_seq;	/* Tail(+1) of data held in tcp send buffer */
...
};
```

### 接收窗口
```
TCP header中有一个Window Size字段，它其实是指接收端的窗口，即接收窗口。用来告知发送端自己所能接收的数据量，从而达到一部分流控的目的。
这里的接收端是相对的，比如A->B A给B发送报文，报文header中的窗口指的是A的接收窗口大小，反之亦然。
```

### 发送窗口与接收窗口关系
```
TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。
其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。
```

### 窗口缩放因子(Window Scaling)
```
以前，window size最大为2的16次方，为65535，随着宽带不断提高，65535字节已经小了，为了突破限制，便有了Window Size Scaling选项，假设window scale为7，也就是要将Window Size的值左移七位，即乘以128。window scale最大为14.
在整个双方的交互过程中，发送方和接收方Window size scaling factor乘积因子必须保持不变，但是发送方的乘积因子和接收方的乘积因子可以不同，由各自决定。
在标志位中有SYN的消息，会在选项中通知接收方，本端具体的放大因子，该消息本身不放大
```

### 拥塞窗口