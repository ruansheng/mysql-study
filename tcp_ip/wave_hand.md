## 四次挥手
![TCP Option](https://github.com/ruansheng/technology-study/blob/master/images/wave_hand.jpg)
```
TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。
TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；
但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；
当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。
```

### 挥手过程
```
第一次挥手:客户端调用close方法，执行主动关闭，会发送一个FIN报文给服务端，从这以后客户端就不能发送数据给服务端了，但是可以接收服务端的数据，这个状态就是[半关闭 half-close]，客户端进入FIN-WAIT-1状态
          FIN报文是可以携带数据的，可以FIN+PSH，FIN需要消耗一个序列号
第二次挥手:服务端收到FIN包以后回复ACK报文给客户端，服务端进入CLOSE_WAIT状态，客户端收到ACK之后进入FIN-WAIT-2状态

第三次挥手:服务端也没有数据要发送了，发送FIN报文给客户端，然后服务端进入LAST-ACK状态，等待客户端的ACK，这里的FIN也要消耗一个序列号

第四次挥手:客户端收到服务端的FIN报文之后，回复ACK报文给服务端，客户端进入TIME_WAIT状态，等待2个MSL以后进入CLOSED状态；此时服务端收到客户端的ACK之后，服务端也进入CLOSED状态
```

### 问题
```
1.为什么这里的FIN包要消耗一个序列号？
  如果客户端发送完数据，立马发送FIN报文，这时候ACK回复客户端就不知道是确认的PSH还是确认的FIN，可能PSH的数据丢了

2.为什么挥手要四次，变为三次可以吗？
  可以，因为有延迟确认的存在，第二步经常会和第三步合并在一起；发了FIN包之后就进入半关闭状态，表示客户端不会给服务端发送数据了，
  服务端这时候还是可以给客户端发数据的，如果这时候服务端没有数据要发送给客户端了，那么可以把ACK和FIN合并一起发给客户端，这样就成了三次挥手了
```